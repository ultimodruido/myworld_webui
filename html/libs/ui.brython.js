__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1653508520900, "ui.buttons": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom browser import html\nfrom .classes import Element\nfrom .utils import get_classes\n\n\nclass Button(Element):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,element=None ,has_icon=False ,right_icon=False ,\n button_class_attr=None ,icon_class_attr=None ):\n \n  if button_class_attr is None :\n   button_class_attr=[\"ui\",\"button\"]\n   if has_icon:\n    button_class_attr.insert(1,\"icon\")\n    if right_icon:\n     button_class_attr.insert(1,\"right\")\n     \n  super().__init__(element,html.BUTTON,button_class_attr)\n  \n  \n  self._text=self.element.text\n  \n  \n  self.has_icon=has_icon\n  self.right_icon=right_icon\n  self.icon_element=None\n  \n  for child in self.element.children:\n   if isinstance(child,html.I)and \"icon\"in get_classes(child):\n    self.icon_element=Element(child,html.I)\n    icon_class_attr=self.icon_element.get_classes()\n    \n  if self.has_icon:\n   if self.icon_element is None :\n    self.icon_element=Element(html.I(),html.I)\n    \n    \n    if icon_class_attr is None :\n     icon_class_attr=[\"icon\"]\n     \n   self.set_icon(icon_class_attr)\n   \n def set_icon(self,icon_classes):\n  if \"icon\"not in icon_classes:\n   icon_classes.append(\"icon\")\n  self.icon_element.set_classes(icon_classes)\n  \n def refresh(self):\n  self.clear()\n  \n  \n  if self.has_icon:\n   self.element <=self.icon_element.element\n   \n   \n  self.element <=self._text\n  \n  \nclass AnimatedButton:\n ''\n\n \n pass\n \n \nclass LabeledButton:\n ''\n\n \n pass\n", ["browser", "ui.classes", "ui.utils"]], "ui.classes": [".py", "''\n\n\n\n\n\n\n\nfrom typing import List\nfrom browser import document\nfrom .utils import add_classes,get_classes,set_classes,remove_classes,replace_classes,set_color,set_size\n\n\n\n\n\nclass MissingClassAttributes(Exception):\n pass\n \n \nclass Element:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,element,element_type,class_attr=None ):\n \n \n  if isinstance(element,str):\n   self.element=document[element]\n   \n  elif isinstance(element,element_type):\n   self.element=element\n   \n  else :\n   self.element=element_type()\n   if class_attr is None :\n    raise MissingClassAttributes(\"[E] parameter 'class_attr' in Element class cannot be None\")\n   else :\n    self.set_classes(class_attr)\n    \n  self._text=self.element.text\n  \n def __le__(self,other):\n  ''\n\n\n  \n  if issubclass(type(other),Element):\n   self.element <=other.element\n  else :\n   self.element <=other\n   \n def clear(self):\n  ''\n  self.element.html=\"\"\n  \n def refresh(self):\n  ''\n  self.clear()\n  self.element <=self._text\n  \n def add_classes(self,class_list:List[str])->None :\n  ''\n\n\n\n  \n  return add_classes(self.element,class_list)\n  \n def get_classes(self)->List[str]:\n  ''\n\n\n\n  \n  return get_classes(self.element)\n  \n def set_classes(self,class_list:List[str])->None :\n  ''\n\n\n\n  \n  return set_classes(self.element,class_list)\n  \n def remove_classes(self,class_list:List[str]):\n  ''\n\n\n\n  \n  return remove_classes(self.element,class_list)\n  \n def replace_classes(self,plus_classes:List[str],minus_classes:List[str]):\n  ''\n\n\n\n\n\n\n\n  \n  return replace_classes(self.element,plus_classes,minus_classes)\n  \n def clear_content(self):\n  ''\n  self.element.html=\"\"\n  \n def set_text(self,text):\n  ''\n  self._text=text\n  self.refresh()\n  \n def set_color(self,color):\n  ''\n\n\n\n\n\n\n\n  \n  set_color(self.element,color)\n  \n def set_size(self,size):\n  ''\n\n\n\n\n\n\n  \n  set_size(self.element,size)\n  \n def set_event_callback(self,event,callback):\n  ''\n  self.element.bind(event,callback)\n  \n def set_clicked_callback(self,callback):\n  ''\n  self.set_event_callback(\"click\",callback)\n  \n def hide(self):\n  ''\n  self.element.hidden=True\n  \n def show(self):\n  ''\n  self.element.hidden=False\n  \n def enable(self):\n  ''\n  self.element.disabled=False\n  \n def disable(self):\n  ''\n  self.element.disabled=True\n  \n  \nclass ElementItem(Element):\n ''\n\n \n pass\n \n \nclass ElementContainer(Element):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,element,element_type,item_type,has_placeholder=False ,parse_content=False ,class_attr=None ):\n  super().__init__(element,element_type,class_attr)\n  \n  if has_placeholder:\n   self.clear()\n   \n  if not issubclass(item_type,ElementItem):\n   raise TypeError(\"Parameter 'item_type' must inherit from ElementItem\")\n  self.item_type=item_type\n  \n  if parse_content:\n   self.items=[ElementItem(child,type(child))for child in self.element.children]\n  else :\n   self.items=list()\n   \n def add_element(self,element):\n  ''\n\n\n\n\n  \n  if not isinstance(element,ElementItem):\n   raise TypeError(\"Parameter 'element' must inherit from ElementItem\")\n  self.items.append(element)\n  self <=element\n  \n def refresh(self):\n  ''\n  self.clear()\n  for item in self.items:\n   self <=item\n   \n def empty(self):\n  ''\n  self.items.clear()\n  self.refresh()\n", ["browser", "typing", "ui.utils"]], "ui.contentmanager": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom browser import html\nfrom .classes import Element\n\n\n\nclass ContentManager(Element):\n def __init__(self,element,start_at=1):\n  super().__init__(element,html.DIV)\n  self.content=[Element(child,type(child))for child in self.element.children]\n  self.n_contents=len(self.content)\n  self.active_content=0\n  self.activate_content(start_at)\n  \n def add_content(self,content):\n  if isinstance(content,Element):\n   self.content.append(content)\n  else :\n   self.content.append(Element(content,type(content)))\n   \n def activate_content(self,content_number:int)->None :\n  ''\n\n\n  \n  if 0 <content_number <=self.n_contents:\n   self.active_content=content_number\n   for index,content in enumerate(self.content,start=1):\n    if index ==content_number:\n     content.show()\n    else :\n     content.hide()\n     \n def activate_content_by_id(self,id):\n  for content in self.content:\n   if content.element.id ==id:\n    content.show()\n   else :\n    content.hide()\n    \n def refresh(self):\n  self.clear()\n  for content in self.content:\n   self <=content\n", ["browser", "ui.classes"]], "ui.dropdown": [".py", "from browser import html,alert,window\nfrom .classes import Element\nfrom .menu import MenuContainer,MenuItem\n\n\njq=window.jQuery\n\n\nclass DropdownItem(MenuItem):\n ''\n\n\n\n\n\n \n \n def __init__(self,element,class_attr=[\"item\"]):\n  super().__init__(element,html.DIV,class_attr)\n  \n  \nclass Dropdown(Element):\n\n def __init__(self,element,parse_content=False ,default_text=None ,use_menu=None ,menu_item_type=DropdownItem,\n class_attr=None ,\n icon_class_attr=None ):\n \n  alert(\"Warning!! class Dropdown is not ready, only SelectionDropdown is functional\")\n  \n  if class_attr is None :\n   class_attr=[\"ui\",\"dropdown\"]\n   \n   \n  super().__init__(element,html.DIV,class_attr)\n  \n  if parse_content is True :\n   self.__init_parsing(menu_item_type)\n  else :\n   self.__init_from_scratch(use_menu,menu_item_type,default_text,icon_class_attr)\n   \n def __init_parsing(self,item_type):\n \n  raise NotImplementedError(\"the 'parse_content' option is not yet available\")\n  \n def __init_from_scratch(self,use_menu,menu_item_type,default_text,icon_class_attr):\n \n \n  if icon_class_attr is None :\n   icon_class_attr=[\"dropdown\",\"icon\"]\n  self.icon=Element(None ,html.I,icon_class_attr)\n  \n  \n  self.text=None\n  if default_text is not None :\n   if isinstance(default_text,str):\n    self.text=Element(None ,html.DIV,class_attr=[\"text\"])\n    self.text.set_text(default_text)\n   else :\n   \n   \n    pass\n    \n    \n  self.menu_item_type=menu_item_type\n  if use_menu is not None :\n   if isinstance(use_menu,MenuContainer):\n    self.menu=use_menu\n   else :\n    raise TypeError(f\"use_menu must be derived from ManuContainer, not {type(use_menu)}\")\n  else :\n   self.menu=MenuContainer(None )\n   \n def add_element(self,element):\n  ''\n\n\n\n\n  \n  if not isinstance(element,self.menu_item_type):\n   raise TypeError(f\"element should be of type MenuItem, not {type(element)}\")\n  self.menu.add_element(element)\n  \n def refresh(self):\n  ''\n  self.clear()\n  \n  \n  if self.text is not None :\n   self <=self.text\n   \n   \n  self <=self.icon\n  \n  \n  self <=self.menu\n  \n  \nclass SelectionDropdown(Element):\n def __init__(self,element,input_name,parse_content=False ,default_text=None ,use_menu=None ,\n menu_item_type=DropdownItem,\n class_attr=None ,\n icon_class_attr=None ):\n \n  if class_attr is None :\n   class_attr=[\"ui\",\"selection\",\"dropdown\"]\n   \n   \n  super().__init__(element,html.DIV,class_attr)\n  \n  if parse_content is True :\n   self.__init_parsing(menu_item_type)\n  else :\n   self.__init_from_scratch(input_name,use_menu,menu_item_type,default_text,icon_class_attr)\n   \n def __init_parsing(self,item_type):\n \n  raise NotImplementedError(\"the 'parse_content' option is not yet available\")\n  \n def __init_from_scratch(self,input_name,use_menu,menu_item_type,default_text,icon_class_attr):\n \n \n \n  if not isinstance(input_name,str):\n   raise TypeError(f\"input_name must be a string, got {type(input_name)}\")\n  self.input_field=Element(None ,html.INPUT,class_attr=[])\n  self.input_field.element.attrs[\"type\"]=\"hidden\"\n  self.input_field.element.attrs[\"id\"]=input_name\n  \n  \n  if icon_class_attr is None :\n   icon_class_attr=[\"dropdown\",\"icon\"]\n  self.icon=Element(None ,html.I,icon_class_attr)\n  \n  \n  self.text=None\n  if default_text is not None :\n   if isinstance(default_text,str):\n    self.text=Element(None ,html.DIV,class_attr=[\"text\"])\n    self.text.set_text(default_text)\n   else :\n    raise TypeError(f\"default text must be a string, got {type(default_text)}\")\n    \n    \n  self.menu_item_type=menu_item_type\n  if use_menu is not None :\n   if isinstance(use_menu,MenuContainer):\n    self.menu=use_menu\n   else :\n    raise TypeError(f\"use_menu must be derived from MenuContainer, not {type(use_menu)}\")\n  else :\n   self.menu=MenuContainer(None ,item_type=DropdownItem)\n   \n  self.refresh()\n  \n  jq(self.element).dropdown()\n  \n  \n def refresh(self):\n  ''\n  self.clear()\n  \n  \n  self <=self.input_field\n  \n  \n  if self.text is not None :\n   self <=self.text\n   \n   \n  self <=self.icon\n  \n  \n  self <=self.menu\n  \n def get_item(self):\n  try :\n   return self.input_field.element.attrs[\"value\"]\n  except KeyError:\n  \n   return None\n   \n def add_element(self,element):\n  ''\n\n\n\n\n  \n  if not isinstance(element,self.menu_item_type):\n   raise TypeError(f\"element should be of type MenuItem, not {type(element)}\")\n  self.menu.add_element(element)\n  \n def get_value(self):\n  ''\n  return jq(self.element).dropdown('get value')\n  \n def empty(self):\n  self.menu.empty()\n  \n def clear_value(self):\n  return jq(self.element).dropdown('restore defaults')\n  \n  \nclass MultipleSelectionDropdown(Element):\n ''\n\n \n pass\n", ["browser", "ui.classes", "ui.menu"]], "ui.dropzone": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom browser import html\nfrom .classes import Element\n\n\ndef _handle_dragover(evt):\n evt.stopPropagation()\n evt.preventDefault()\n evt.dataTransfer.dropEffect='copy'\n \n \nclass DropZone(Element):\n ''\n\n \n def __init__(self,element,drop_callback,class_attr=[\"ui content\"]):\n  super().__init__(element,html.DIV,class_attr)\n  self.set_drop_callback(drop_callback)\n  \n def set_drop_callback(self,drop_callback):\n  self.set_event_callback(\"drop\",drop_callback)\n  self.set_event_callback(\"dragover\",_handle_dragover)\n  \n", ["browser", "ui.classes"]], "ui.labels": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\nfrom browser import document,html\nfrom .utils import get_classes\nfrom .classes import Element\n\n\nclass Label(Element):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,element=None ,*,is_link=False ,has_detail=False ,class_attr=None ):\n \n \n  if is_link:\n   label_type=html.A\n  else :\n   label_type=html.DIV\n   \n  if class_attr is None :\n   class_attr=[\"ui label\"]\n   \n  super().__init__(element,label_type,class_attr)\n  \n  self.detail_element=None\n  self.has_detail=has_detail\n  \n  self._text=self.element.text\n  \n  self._detail_text=\"\"\n  \n  if self.has_detail:\n  \n   for child in self.element.children:\n    if isinstance(child,html.DIV)and child.class_name ==\"detail\":\n     self.detail_element=Element(child,html.DIV)\n     self._detail_text=child.text\n     \n     self._text=''.join(self._text.split(child.text))\n   if self.detail_element is None :\n    self.detail_element=Element(html.DIV(),html.DIV)\n    self.detail_element.set_classes([\"detail\"])\n    \n def set_detail_text(self,text:str)->None :\n  ''\n\n\n\n  \n  self._detail_text=text\n  self.refresh()\n  \n def refresh(self):\n  self.clear()\n  \n  self.element <=self._text\n  \n  if self.has_detail:\n   self.detail_element.set_text(self._detail_text)\n   self.element <=self.detail_element.element\n   \n   \nclass IconLabel(Label):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,element=None ,is_link=False ,has_detail=False ,right_icon=False ,\n label_class_attr=None ,icon_class_attr=None ):\n \n  if label_class_attr is None :\n   if right_icon:\n    label_class_attr=['ui','right','icon','label']\n   else :\n    label_class_attr=['ui','left','icon','label']\n    \n    \n    \n    \n  self.right_icon=right_icon\n  \n  self.icon_element=None\n  \n  \n  super().__init__(element,is_link=is_link,has_detail=has_detail,class_attr=label_class_attr)\n  \n  for child in self.element.children:\n   if isinstance(child,html.I)and \"icon\"in get_classes(child):\n    self.icon_element=Element(child,html.I)\n    \n  if self.icon_element is None :\n   self.icon_element=Element(html.I(),html.I)\n   \n   \n  if type(icon_class_attr)is str:\n   icon_class_attr=[icon_class_attr]\n   \n  if icon_class_attr is None :\n   icon_class_attr=[\"icon\"]\n   \n  self.set_icon(icon_class_attr)\n  \n def set_icon(self,icon_classes):\n  if \"icon\"not in icon_classes:\n   icon_classes.append(\"icon\")\n  self.icon_element.set_classes(icon_classes)\n  \n def refresh(self):\n  self.clear()\n  \n  if not self.right_icon:\n   self.element <=self.icon_element.element\n   \n   \n  self.element <=self._text\n  \n  \n  if self.has_detail:\n   self.detail_element.set_text(self._detail_text)\n   self.element <=self.detail_element.element\n   \n   \n  if self.right_icon:\n   self.element <=self.icon_element.element\n", ["browser", "ui.classes", "ui.utils"]], "ui.lists": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\nfrom browser import html\n\nfrom .classes import ElementContainer,ElementItem\n\n\nclass ListItem(ElementItem):\n ''\n\n\n\n\n\n \n def __init__(self,element=None ):\n \n  super().__init__(element,html.DIV,[\"item\"])\n  \n  \nclass ListContainer(ElementContainer):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,element,item_type=ListItem,has_placeholder=False ,parse_content=False ,class_attr=None ):\n  if class_attr is None :\n   class_attr=[\"ui\",\"list\"]\n  super().__init__(element,html.DIV,item_type,has_placeholder,parse_content,class_attr)\n  \n", ["browser", "ui.classes"]], "ui.menu": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom browser import html\n\nfrom .classes import ElementContainer,ElementItem\n\n\nclass MenuItem(ElementItem):\n ''\n\n\n\n\n\n \n def __init__(self,element,element_type=html.A,class_attr=[\"item\"]):\n  super().__init__(element,element_type,class_attr)\n  \n  \nclass MenuContainer(ElementContainer):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,element,item_type=MenuItem,right_menu=None ,has_placeholder=False ,parse_content=False ,\n class_attr=None ):\n  if class_attr is None :\n   class_attr=[\"ui\",\"menu\"]\n  super().__init__(element,html.DIV,item_type,has_placeholder,parse_content,class_attr)\n  \n  self.has_right_menu=False\n  self.right_menu=None\n  if isinstance(right_menu,MenuContainer):\n   self.has_right_menu=True\n   self.right_menu=right_menu\n  self.refresh()\n  \n def add_element(self,element):\n  ''\n\n\n\n\n  \n  if not isinstance(element,self.item_type):\n   raise TypeError(f\"element should be of type MenuItem, not {type(element)}\")\n  self <=element\n  self.items.append(element)\n  self.refresh()\n  \n def add_right_element(self,element):\n  ''\n\n\n\n\n  \n  \n  self.right_menu.add_element(element)\n  \n def refresh(self):\n  ''\n  self.clear()\n  for item in self.items:\n   self <=item\n  if self.has_right_menu:\n   self.right_menu.refresh()\n   self <=self.right_menu\n   \n   \n   \n", ["browser", "ui.classes"]], "ui.slider": [".py", "''\n\n\n\n\n\n\n\n\n\n\nfrom browser import html,window\nfrom .classes import Element\n\njq=window.jQuery\n\n\nclass Slider(Element):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,element=None ,\n slider_class_attr=None ,min_value=0,max_value=10,step_value=1,get_mouse_wheel=False ):\n \n  if slider_class_attr is None :\n   slider_class_attr=[\"ui\",\"slider\"]\n   \n  super().__init__(element,html.DIV,slider_class_attr)\n  \n  if get_mouse_wheel:\n   self.element.set_event_callback(\"wheel\",self.get_mousewheel)\n   \n  self.min_value=min_value\n  self.max_value=max_value\n  \n  slider_settings={\n  'min':self.min_value,\n  'max':self.max_value,\n  'start':self.min_value,\n  'step':step_value\n  }\n  \n  jq(self.element).slider(slider_settings)\n  \n def refresh(self):\n  ''\n  pass\n  \n def get_mousewheel(self,event):\n \n  event.preventDefault()\n  \n  actual_value=self.get_value()\n  try :\n   value=int(event.deltaY)\n  except ValueError as e:\n   return\n   \n   \n  if value <0:\n   new_value=min(actual_value+1,self.max_value)\n  elif value >0:\n   new_value=max(actual_value -1,self.min_value)\n   \n  if new_value !=actual_value:\n   self.set_value(new_value)\n   \n def get_value(self):\n  ''\n  return jq(self.element).slider('get value')\n  \n def set_value(self,value):\n  ''\n  jq(self.element).slider('set value',value)\n", ["browser", "ui.classes"]], "ui.steps": [".py", "''\n\n\n\n\n\n\n\n\n\nfrom browser import html\nfrom .classes import ElementContainer,ElementItem\nfrom .utils import replace_classes\n\n\nclass StepItem(ElementItem):\n ''\n\n\n\n\n\n \n \n def __init__(self,element,class_attr=[\"step\"]):\n  super().__init__(element,html.DIV,class_attr)\n  \n  \nclass StepsContainer(ElementContainer):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,element,\n active_class=\"active\",completed_class=\"completed\",\n extra_active_classes=None ,extra_completed_classes=None ,extra_upcoming_classes=None ,\n class_attr=None ,item_type=StepItem,has_placeholder=False ,parse_content=False ):\n \n  if class_attr is None :\n   class_attr=[\"ui\",\"steps\"]\n  if extra_upcoming_classes is None :\n   extra_upcoming_classes=[]\n  if extra_active_classes is None :\n   extra_active_classes=[]\n  if extra_completed_classes is None :\n   extra_completed_classes=[]\n   \n  super().__init__(element,html.DIV,item_type,has_placeholder,parse_content,class_attr)\n  \n  self.active_step=0\n  self.n_steps=len(self.items)\n  \n  self.active_class=active_class\n  self.completed_class=completed_class\n  self.extra_active_classes=extra_active_classes\n  self.extra_completed_classes=extra_completed_classes\n  self.extra_upcoming_classes=extra_upcoming_classes\n  \n def refresh(self):\n  ''\n\n  \n  \n  pass\n  \n def next_step(self):\n  ''\n\n\n  \n  \n  if self.active_step <self.n_steps:\n   self.active_step +=1\n   \n  self.goto_step(self.active_step)\n  \n def previous_step(self):\n  ''\n\n\n  \n  \n  if self.active_step >0:\n   self.active_step -=1\n   \n  self.goto_step(self.active_step)\n  \n def goto_step(self,step_number:int):\n  ''\n\n\n\n\n  \n  \n  \n  if 0 <=step_number <=self.n_steps:\n   self.active_step=step_number\n   \n  for index,step in enumerate(self.items,start=1):\n   if index <self.active_step:\n    self._set_completed(step)\n   elif index ==self.active_step:\n    self._set_active(step)\n   else :\n    self._set_upcoming(step)\n    \n def _set_active(self,step):\n \n \n \n  adding_classes=self.extra_active_classes\n  adding_classes.insert(0,self.active_class)\n  removing_classes=self.extra_completed_classes+self.extra_upcoming_classes\n  removing_classes.insert(0,self.completed_class)\n  replace_classes(step.element,\n  adding_classes,\n  removing_classes\n  )\n  \n def _set_completed(self,step):\n \n \n \n  adding_classes=self.extra_completed_classes\n  adding_classes.insert(0,self.completed_class)\n  removing_classes=self.extra_active_classes+self.extra_upcoming_classes\n  removing_classes.insert(0,self.active_class)\n  replace_classes(step.element,\n  adding_classes,\n  removing_classes\n  )\n  \n def _set_upcoming(self,step):\n \n \n \n  adding_classes=self.extra_upcoming_classes\n  removing_classes=self.extra_active_classes+self.extra_completed_classes\n  removing_classes.insert(0,self.active_class)\n  removing_classes.insert(1,self.completed_class)\n  replace_classes(step.element,\n  adding_classes,\n  removing_classes\n  )\n  \n  \n", ["browser", "ui.classes", "ui.utils"]], "ui.tabs": [".py", "''\n\n\n\n\n\n", []], "ui.uiexception": [".py", "''\n\n\n\n\n\n\n\nclass UiException(Exception):\n ''\n pass\n \n \nclass ClassListTypeError(UiException):\n ''\n pass\n \n \nclass ColorValueError(UiException):\n ''\n pass\n \n \nclass ColorTypeError(UiException):\n ''\n pass\n", []], "ui.utils": [".py", "''\n\n\n\n\n\nfrom typing import List\n\nfrom .uiexception import ClassListTypeError,ColorValueError,ColorTypeError\n\n\nLOG=False\n\n\ndef get_classes(element)->List[str]:\n ''\n\n\n\n\n\n\n \n class_list=element.class_name.split()\n return class_list\n \n \ndef set_classes(element,class_list:List[str])->None :\n ''\n\n\n\n\n\n\n \n _check_class_list_input_type(class_list)\n \n \n \n element.class_name=' '.join(class_list)\n \n \ndef add_classes(element,class_list:List[str])->None :\n ''\n\n\n\n\n\n\n \n _check_class_list_input_type(class_list)\n \n element_classes=get_classes(element)+class_list\n \n set_classes(element,element_classes)\n \n \ndef remove_classes(element,class_list:List[str])->None :\n ''\n\n\n\n\n\n\n \n _check_class_list_input_type(class_list)\n \n element_classes=get_classes(element)\n new_class_list=[cls for cls in element_classes if cls not in class_list]\n \n set_classes(element,new_class_list)\n \n \ndef replace_classes(element,plus_classes:List[str],minus_classes:List[str])->None :\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n remove_classes(element,minus_classes)\n \n add_classes(element,plus_classes)\n \n \ndef _check_class_list_input_type(class_list:List[str])->None :\n if not isinstance(class_list,list):\n  raise ClassListTypeError(f\"Param: class_list is not a list but: {type(class_list)}\")\n  \n  \n  \n  \n  \nCOLORS=[\"primary\",\"secondary\",\"red\",\"orange\",\"yellow\",\"olive\",\"green\",\"teal\",\"blue\",\"violet\",\"purple\",\n\"pink\",\"brown\",\"grey\",\"black\"]\n\n\ndef set_color(element,color:str)->None :\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n _check_color_input_type(color)\n _check_color_input_value(color)\n \n \n remove_classes(element,COLORS)\n \n \n class_list=[color]\n \n \n add_classes(element,class_list)\n \n \ndef _check_color_input_type(color:str):\n if not isinstance(color,str):\n  raise ColorTypeError(f\"Param: color is not a string but: {type(color)}\")\n  \n  \ndef _check_color_input_value(color:str):\n if color not in COLORS:\n  raise ColorValueError(f\"Param: color is not in the standard list: {COLORS}\\n\"\n  f\"use replace_classes instead to be sure to remove the old color\")\n  \n  \n  \n  \n  \nSIZES=[\"mini\",\"tiny\",\"small\",\"large\",\"huge\",\"massive\"]\n\n\ndef set_size(element,size:str)->None :\n ''\n\n\n\n\n\n\n\n\n\n \n \n remove_classes(element,SIZES)\n new_class_list=[]\n \n if isinstance(size,str):\n  new_class_list=[size]\n  \n elif isinstance(size,list):\n  new_class_list=size\n add_classes(element,new_class_list)\n \n \n \n", ["typing", "ui.uiexception"]], "ui": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\nVERSION=\"0.0.1m\"\nprint(f\"[*] Brymantic UI version: {VERSION}\")\n", [], 1]}
__BRYTHON__.update_VFS(scripts)
